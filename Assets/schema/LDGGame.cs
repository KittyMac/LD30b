

//
// Autogenerated by gaxb ( https://github.com/SmallPlanet/gaxb )
//
using System.Collections.Generic;
using System;
using UnityEngine;

public partial class LDGGame : LDGGameBase {

	public static LDGGame CreateGame() {
		LDGGame game = new LDGGame();
		game.SetSaveGameTag (5);


		// 0) Load all equipment
		List<LDGEquipment> allEquipment = LDGAllEquipment.GetAllEquipment ();

		// 1) put random copies of all equipment into game.Equipment (this is the stuff floating in space)
		// 1a) Should at least be one of everything
		foreach (LDGEquipment equipment in allEquipment) {
			game.AddSpaceEquipment (equipment);
		}

		// 1b) Now add more random copies for fun
		int copies = UnityEngine.Random.Range (allEquipment.Count, allEquipment.Count * 3);
		for (int i = 0; i < copies; i++) {
			LDGEquipment equipment = allEquipment [UnityEngine.Random.Range (0, allEquipment.Count)];
			game.AddSpaceEquipment (equipment);
		}


		// 2) add the planets
		LDGPlanet redPlanet = new LDGPlanet(100.0f, 0.0f);
		LDGPlanet bluePlanet = new LDGPlanet(100.0f, 0.0f);
		redPlanet.parent = game;
		bluePlanet.parent = game;
		game.Planets.Add (bluePlanet);
		game.Planets.Add (redPlanet);

		return game;
	}

	public void AddSpaceEquipment(LDGEquipment equipment) {
		LDGEquipment clone = equipment.Clone ();
		clone.position = new cVector3 (UnityEngine.Random.Range (96, 750), UnityEngine.Random.Range (38, 532), 0);
		clone.velocity = new cVector3 (UnityEngine.Random.Range (-6, 6), UnityEngine.Random.Range (-6, 6), 0);
		Equipments.Add (clone);
	}

	public LDGPlanet redPlanet()
	{
		return Planets [1] as LDGPlanet;
	}

	public LDGPlanet bluePlanet()
	{
		return Planets [0] as LDGPlanet;
	}

	public bool AddEquipmentToPlanetBuildQueue(LDGEquipment e, LDGPlanet p) {

		if (p.Equipments.Count > 13) {
			return false;
		}

		// 0 remove the equipment from space
		Equipments.Remove (e);

		// 1 add it to the planet
		p.Equipments.Add (e);

		return true;
	}

	public void BuildCurrentShipForPlanet(LDGPlanet p) {

		// Not allowed to build empty ships
		if (p.Equipments.Count == 0) {
			return;
		}

		LDGShip ship = new LDGShip();
		Vector3 exitPos = new Vector3 (934,28,0);

		ship.player = 0;

		if (p == redPlanet ()) {
			ship.player = 1;
			exitPos = new Vector3 (25,583,0);
		}

		ship.Equipments.AddRange (p.Equipments);
		p.Equipments.Clear ();

		ship.InitCombatValues ();

		float anim = 0.0f;
		foreach (LDGEquipment e in ship.Equipments) {
			e.RemoveSprite (anim, exitPos);
			anim += 1.0f / ship.Equipments.Count;
		}

		p.AddShipToBuild (ship);
	}

	public void AdvanceGame (PUGameObject ShipsContainer, PUGameObject EquipmentContainer){
		foreach (LDGPlanet p in Planets) {
			p.AdvanceBuildQueue (ShipsContainer);
		}

		foreach (LDGEquipment e in Equipments) {
			Vector3 v = e.sprite.gameObject.transform.localPosition;
			v.x += e.velocity.x;
			v.y += e.velocity.y;
			e.sprite.gameObject.transform.localPosition = v;

			e.velocity.x *= 0.95f;
			e.velocity.y *= 0.95f;
		}

		PerformShipMovementForPlayer(0);
		PerformShipMovementForPlayer(1);

		// Remove any casualties
		for(int i = Ships.Count-1; i>= 0; i--){
			LDGShip ship = Ships [i] as LDGShip;
			if (ship.structure <= 0) {

				// Remove the equipment from this ship, put it back into space
				foreach (LDGEquipment e in ship.Equipments) {
					Equipments.Add (e);

					Vector3 p = ship.sprite.gameObject.transform.localPosition;
					e.position = new cVector3(p.x, p.y, p.z);
					e.velocity = new cVector3 (UnityEngine.Random.Range (-6, 6), UnityEngine.Random.Range (-6, 6), 0);

					e.GetSprite (EquipmentContainer);
				}

				ship.sprite.unload ();
				Ships.Remove (ship);
			}
		}



	}

	// We going to do a generic flocking algorithm for the ships, always targetting weakest
	public void PerformShipMovementForPlayer(int p){
		// Figure out the flock center and the flock velocity

		Vector3 center = Vector3.zero;
		Vector3 velocity = Vector3.zero;
		float n = 0;

		foreach (LDGShip ship in Ships)
		{
			if (ship.player == p) {
				center = center + ship.sprite.gameObject.transform.localPosition;
				velocity = velocity + ship.velocity;
				n++;
			}
		}

		center = center / n;
		velocity = velocity / n;

		Vector3 targetPosition = new Vector3 (484,351, 0);

		// Find the "weakest" target of the other player; ideally, weakest target of the same class ship
		LDGShip targetShip = null;
		foreach (LDGShip ship in Ships) {
			if (ship.player != p) {
				if (targetShip == null || ship.TotalHealth () < targetShip.TotalHealth ()) {
					targetShip = ship;
				}
			}
		}

		if (targetShip != null) {
			targetPosition = targetShip.sprite.gameObject.transform.localPosition;
		}

		foreach (LDGShip ship in Ships) {
			if (ship.player == p) {
				PerformFlocking (ship, center, velocity, targetPosition);

				if (targetShip != null) {
					FireAllAvailableWeapons (ship, targetShip);
				}
			}
		}
	}

	public void FireAllAvailableWeapons(LDGShip fromShip, LDGShip toShip) {
		float d = Vector3.Distance(fromShip.sprite.gameObject.transform.localPosition, toShip.sprite.gameObject.transform.localPosition);

		foreach (LDGEquipment e in fromShip.Equipments) {
			// Are we in range? (Are we even a weapon?)
			if (e.range > 0 && e.range > d) {

				e.reloadCounter -= Time.deltaTime;
				// Have I reloaded?
				if (e.reloadCounter <= 0) {
					// Fire my weapon, reset the reload counter
					toShip.PerformDamageFromWeapon (e);
					e.reloadCounter = e.reload;
				}
			}
		}
	}

	public void PerformFlocking(LDGShip ship, Vector3 flockCenter, Vector3 flockVelocity, Vector3 targetPosition) {

		float maxVelocity = ship.MaxVelocity ();
		float minVelocity = 0.5f;
		float randomness = 200.0f;

		targetPosition.x = Mathf.Clamp (targetPosition.x, 50, 960-100);
		targetPosition.y = Mathf.Clamp (targetPosition.y, 50, 600-100);

		Vector3 randomize = new Vector3 ((UnityEngine.Random.value *2) -1, (UnityEngine.Random.value * 2) -1, (UnityEngine.Random.value * 2) -1);
		randomize.Normalize();
		flockCenter = flockCenter - ship.sprite.gameObject.transform.localPosition;
		flockVelocity = flockVelocity - ship.velocity;
		targetPosition = targetPosition - ship.sprite.gameObject.transform.localPosition;
		Vector3 calc = (flockCenter + flockVelocity + targetPosition * 2 + randomize * randomness);



		ship.velocity = ship.velocity + calc * Time.deltaTime;

		// enforce minimum and maximum speeds for the boids
		float speed = ship.velocity.magnitude;
		if (speed > maxVelocity)
		{
			ship.velocity = ship.velocity.normalized * maxVelocity;
		}
		else if (speed < minVelocity)
		{
			ship.velocity = ship.velocity.normalized * minVelocity;
		}

		ship.sprite.gameObject.transform.localPosition = ship.sprite.gameObject.transform.localPosition + ship.velocity * Time.fixedDeltaTime;


		// fix rotation so we look the direction we're moving

		float ang = Mathf.Atan2(ship.velocity.y, ship.velocity.x);
		ship.sprite.gameObject.transform.localEulerAngles = new Vector3 (0, 0, ang * 57.29577951f);
	}
}

