

//
// Autogenerated by gaxb ( https://github.com/SmallPlanet/gaxb )
//
using System.Collections.Generic;
using System;
using UnityEngine;

public partial class LDGGame : LDGGameBase {

	public static LDGGame CreateGame() {
		LDGGame game = new LDGGame();
		game.SetSaveGameTag (5);


		// 0) Load all equipment
		List<LDGEquipment> allEquipment = LDGAllEquipment.GetAllEquipment ();

		// 1) put random copies of all equipment into game.Equipment (this is the stuff floating in space)
		// 1a) Should at least be one of everything
		foreach (LDGEquipment equipment in allEquipment) {
			game.AddSpaceEquipment (equipment);
		}

		// 1b) Now add more random copies for fun
		int copies = UnityEngine.Random.Range (allEquipment.Count, allEquipment.Count * 3);
		for (int i = 0; i < copies; i++) {
			LDGEquipment equipment = allEquipment [UnityEngine.Random.Range (0, allEquipment.Count)];
			game.AddSpaceEquipment (equipment);
		}


		// 2) add the planets
		LDGPlanet redPlanet = new LDGPlanet(100.0f, 0.0f);
		LDGPlanet bluePlanet = new LDGPlanet(100.0f, 0.0f);
		redPlanet.parent = game;
		bluePlanet.parent = game;
		game.Planets.Add (bluePlanet);
		game.Planets.Add (redPlanet);

		return game;
	}

	public void AddSpaceEquipment(LDGEquipment equipment) {
		LDGEquipment clone = equipment.Clone ();
		clone.position = new cVector3 (UnityEngine.Random.Range (96, 750), UnityEngine.Random.Range (38, 532), 0);
		Equipments.Add (clone);
	}

	public LDGPlanet redPlanet()
	{
		return Planets [1] as LDGPlanet;
	}

	public LDGPlanet bluePlanet()
	{
		return Planets [0] as LDGPlanet;
	}

	public bool AddEquipmentToPlanetBuildQueue(LDGEquipment e, LDGPlanet p) {

		if (p.Equipments.Count > 13) {
			return false;
		}

		// 0 remove the equipment from space
		Equipments.Remove (e);

		// 1 add it to the planet
		p.Equipments.Add (e);

		return true;
	}

	public void BuildCurrentShipForPlanet(LDGPlanet p) {
		LDGShip ship = new LDGShip();
		Vector3 exitPos = new Vector3 (934,28,0);

		ship.player = 0;

		if (p == redPlanet ()) {
			ship.player = 1;
			exitPos = new Vector3 (25,583,0);
		}

		ship.Equipments.AddRange (p.Equipments);
		p.Equipments.Clear ();

		ship.InitCombatValues ();

		float anim = 0.0f;
		foreach (LDGEquipment e in ship.Equipments) {
			e.RemoveSprite (anim, exitPos);
			anim += 1.0f / ship.Equipments.Count;
		}

		p.AddShipToBuild (ship);
	}

	public void AdvanceGame (PUGameObject ShipsContainer){
		foreach (LDGPlanet p in Planets) {
			p.AdvanceBuildQueue (ShipsContainer);
		}

		PerformShipMovementForPlayer(0);
		PerformShipMovementForPlayer(1);
	}

	// We going to do a generic flocking algorithm for the ships, always targetting weakest
	public void PerformShipMovementForPlayer(int p){
		// Figure out the flock center and the flock velocity

		Vector3 center = Vector3.zero;
		Vector3 velocity = Vector3.zero;
		float n = 0;

		foreach (LDGShip ship in Ships)
		{
			center = center + ship.sprite.gameObject.transform.localPosition;
			velocity = velocity + ship.velocity;
			n++;
		}

		center = center / n;
		velocity = velocity / n;

		Vector3 targetPosition = new Vector3 (280, 435, 0);

		foreach (LDGShip ship in Ships) {
			PerformFlocking (ship, center, velocity, targetPosition);
		}
	}

	public void PerformFlocking(LDGShip ship, Vector3 flockCenter, Vector3 flockVelocity, Vector3 targetPosition) {

		float maxVelocity = ship.MaxVelocity ();
		float minVelocity = 0.5f;
		float randomness = 2.0f;


		Vector3 randomize = new Vector3 ((UnityEngine.Random.value *2) -1, (UnityEngine.Random.value * 2) -1, (UnityEngine.Random.value * 2) -1);
		randomize.Normalize();
		flockCenter = flockCenter - ship.sprite.gameObject.transform.localPosition;
		flockVelocity = flockVelocity - ship.velocity;
		targetPosition = targetPosition - ship.sprite.gameObject.transform.localPosition;
		Vector3 calc = (flockCenter + flockVelocity + targetPosition * 2 + randomize * randomness);



		ship.velocity = ship.velocity + calc * Time.deltaTime;

		// enforce minimum and maximum speeds for the boids
		float speed = ship.velocity.magnitude;
		if (speed > maxVelocity)
		{
			ship.velocity = ship.velocity.normalized * maxVelocity;
		}
		else if (speed < minVelocity)
		{
			ship.velocity = ship.velocity.normalized * minVelocity;
		}

		ship.sprite.gameObject.transform.localPosition = ship.sprite.gameObject.transform.localPosition + (ship.velocity * Time.deltaTime);


		// fix rotation so we look the direction we're moving

		float ang = Mathf.Atan2(ship.velocity.y, ship.velocity.x);
		ship.sprite.gameObject.transform.localEulerAngles = new Vector3 (0, 0, ang * 57.29577951f);
	}
}

